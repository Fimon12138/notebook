{"pages":[{"title":"Tags","date":"2021-06-27T01:37:56.219Z","path":"tags/index.html","text":""},{"title":"About","date":"2021-06-27T01:37:56.188Z","path":"about/index.html","text":""},{"title":"Categories","date":"2021-06-27T01:37:56.199Z","path":"categories/index.html","text":""},{"title":"","date":"2021-06-29T07:25:15.503Z","path":"index-page.html","text":"Welcome to Fimon’s Wiki Site这是我的个人Wiki站点，用于记录平时学习的内容，方便以后查阅。 第一次接触Wiki这个词是20年夏天在Shopee深圳实习的时候，他们当时用的是Confluence，但是因为我那会主要做的是测试工具的开发，跟项目关联比较少，一个人在做，所以用的很少。不过对于第一次出来实习的我，这些工具还是给了我很大的冲击，以致在后来经常拿出来跟同学吹牛。 后来继续去了美团北京实习。美团的Wiki一直是他们拿出来宣传的东西——学城，工作时确实经常会在上面看文档，没事的时候也会在上面随便翻翻。时间长了，没有像宣传中所说的从新手到高手，倒是看了好多乱七八糟的东西，比如大家的分享、实习生的面试记录、招聘排序等，我的问题。 离职后觉得这样一个东西用来记记笔记还是很有必要的。当时最先了解到的是Wordpress，也搭建过自己的博客，但是总是不喜欢博客的那种风格，感觉博客更像是写给别人看的。后来也勉强用了一段时间，但是总感觉Wordpress有点复杂，对新手学习成本比较大，后来转而使用Github Pages，在翻Hexo主题时意外发现了这个主题，也算是一种缘分。 总之，感谢Wikitten作者的辛勤付出，也希望我的站点里有一些对你有帮助的内容。"}],"posts":[{"title":"priority queue","date":"2021-12-30T03:49:00.000Z","path":"wiki/刷题/Algorithms/algs4-Princeton/priority-queue/","text":"Priority Queue: remove the largest (or smallest) item. Binary Heaps binary tree complete tree: perfectly balanced, except for the bottom line; binary heap: array representation of a heap-ordered complete binary tree; indices start at 1; parent of node k is at k/2; children of node k are at 2k and 2k+1 ; APIs: insert: add node at end, then swim it up; delete max: exchange root with node at end, then sink it down; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MaxPQ &#123; private int[] pq; private int N; public MaxPQ(int initSize) &#123; if (initSize &lt; 1) throw new IllegalArgumentException(); this.pq = new int[initSize]; this.N = 0; &#125; public int size() &#123; return N; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public void insert(int x) &#123; pq[++N] = x; swim(N); &#125; private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123; exch(k/2, k); k = k / 2; &#125; &#125; public int delMax() &#123; if (isEmpty()) &#123; throw new RuntimeException(&quot;Error: can&#x27;t delete from an empty pq!&quot;); &#125; int max = pq[1]; exch(1, N--); sink(1); pq[N + 1] = 0; return max; &#125; private void sink(int k) &#123; while (2 * k &lt;= N) &#123; int j = 2 * k; if (j &lt; N &amp;&amp; less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125; &#125; private boolean less(int i, int j) &#123; return pq[i] &lt; pq[j]; &#125; private void exch(int i, int j) &#123; int temp = pq[i]; pq[i] = pq[j]; pq[j] = temp; &#125;&#125; Heap Sortcreate max-heap with all N keys, repeatedly remove the maximum key; 1234567891011public class HeapSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;3, 5, 7, 6, 8, 3, 5, 5, 9&#125;; MaxPQ pq = new MaxPQ(20); for (int i : arr) pq.insert(i); for (int i = arr.length - 1; i &gt;= 0; i--) arr[i] = pq.delMax(); System.out.println(Arrays.toString(arr)); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435import java.util.Arrays;public class HeapSort &#123; public static void sort(int[] arr) &#123; int N = arr.length; for (int k = N / 2; k &gt;= 0; k--) sink(arr, k, N); while (N &gt; 1) &#123; exch(arr, 0, --N); sink(arr, 0, N); &#125; &#125; private static void sink(int[] arr, int k, int N) &#123; while (2 * k + 1 &lt; N) &#123; int j = 2 * k + 1; if (j &lt; N - 1 &amp;&amp; less(arr, j, j + 1)) j++; if (!less(arr, k, j)) break; exch(arr, k, j); k = j; &#125; &#125; private static boolean less(int[] arr, int i, int j) &#123; return arr[i] &lt; arr[j]; &#125; private static void exch(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; In-place sorting algorithm with N log N worst-case.","tags":[{"name":"algo","slug":"algo","permalink":"http://wiki.hellofimon.icu/tags/algo/"},{"name":"priority queue","slug":"priority-queue","permalink":"http://wiki.hellofimon.icu/tags/priority-queue/"},{"name":"heap","slug":"heap","permalink":"http://wiki.hellofimon.icu/tags/heap/"}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/"},{"name":"Algorithms","slug":"刷题/Algorithms","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/"},{"name":"algs4-Princeton","slug":"刷题/Algorithms/algs4-Princeton","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/algs4-Princeton/"}]},{"title":"sort","date":"2021-12-17T11:41:00.000Z","path":"wiki/刷题/Algorithms/algs4-Princeton/sort/","text":"Selection SortIn iteration i, find index min of smallest remaining entry. Swap a[i] and a[min]. 123456789101112131415161718public void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int n = arr.length; int p = 0; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr, p, min); p++; &#125;&#125; N^2/2 compares and N exchanges; time complexity: O(n^2), quadratic time, even if input is sorted; Insertion SortIn iteration i, swap a[i] with each larger entry to its left. 123456789101112public void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int n = arr.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]; j--) &#123; swap(arr, j, j-1); &#125; &#125;&#125; best case (the array is already sorted): N-1 compares, 0 exchanges; worst case (the array is in descending order): N^2/2 compares and N^2/2 exchanges; time complexity: O(n^2) Shell SortMove entries more than one position at a time by h-sorting the array. 1234567891011121314151617181920// with increment = 3x+1public void shellSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int n = arr.length; int h = 1; while (h &lt; n / 3) h = 3 * h + 1; while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j-h]; j -= h) &#123; swap(arr, j, j-h); &#125; &#125; h = h / 3; &#125;&#125; Merge SortDivide array into two halves, recursively sort each half, merge two halves. 1234567891011121314151617181920212223242526272829public void merge(int[] arr, int[] aux, int lo, int mid, int hi) &#123; // copy for (int i = lo; i &lt;= hi; i++) aux[i] = arr[i]; int i = lo; int j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) arr[k] = aux[j++]; else if (j &gt; hi) arr[k] = aux[i++]; else if (aux[i] &lt; aux[j]) arr[k] = aux[i++]; else arr[k] = aux[j++]; &#125;&#125;public void sort(int[] arr, int[] aux, int lo, int hi) &#123; if (hi &lt;= lo) &#123; return; &#125; int mid = (lo + hi) / 2; sort(arr, aux, lo, mid); sort(arr, aux, mid + 1, hi); merge(arr, aux, lo, mid, hi);&#125; Analysis: at most NlgN compares, time complexity is O(n * lgn), space complexity is O(N), need an auxiliary array; Bottom-up Merge SortPass through array, merging subarrays of size 1, repeat for subarrays of size 2, 4, 8, 16, …. 12345678public void bottomupMergeSort(int[] arr, int[] aux) &#123; int n = arr.length; for (int sz = 1; sz &lt; n; sz *= 2) &#123; for (int lo = 0; lo &lt; n - sz; lo += 2 * sz) &#123; merge(arr, aux, lo, lo + sz - 1, Math.min(n-1, lo + 2 * sz - 1)); &#125; &#125;&#125; Quick Sort1234567891011121314151617181920212223242526272829303132333435public void quickSort(int[] arr) &#123; StdRandom.shuffle(arr); quickSortHelper(arr, 0, arr.length - 1);&#125;private void quickSortHelper(int[] arr, int lo, int hi) &#123; if (lo &gt;= hi) return; int mid = partition(arr, lo, hi); quickSortHelper(arr, lo, mid - 1); quickSortHelper(arr, mid + 1, hi);&#125;private int partition(int[] arr, int lo, int hi) &#123; int pivot = arr[lo]; int i = lo; int j = hi + 1; while (true) &#123; while (arr[++i] &lt; pivot) if (i == hi) break; while (pivot &lt; arr[--j]) if (j == lo) break; if (i &gt;= j) break; swap(arr, i, j); &#125; swap(arr, lo, j); return j;&#125; Analysis: number of compares is ~ N * lg N; in worst case (already sorted), number of compares is ~ 1/2 N^2; average case: N * lg N so shuffling is needed for performance guarantee; in place but not stable; quick selectIdea: entry a[j] is in place, no larger entry to the left of j, no smaller entry to the right of j; repeat in one subarray, depending on j; finished when j equals k. Exp: LC-215 [https://leetcode.com/problems/kth-largest-element-in-an-array/] takes linear time on average duplicate keysAlgorithm goes quadratic unless partitioning stops on equal keys! 3-way partition: partition array into 3 parts so that: entries between lt and gt equal to partition item v; no larger entries to left of lt; no smaller entries to right of gt; (see dutch national flags in interview questions) 1234567891011121314151617181920public void sortThreeWay(int[]arr, int lo, int hi) &#123; if (hi &lt;= lo) return; int lt = lo; int gt = hi; int pivot = arr[lo]; int i = lo; while (i &lt;= gt) &#123; if (arr[i] &lt; pivot) swap(arr, lt++, i++); else if (arr[i] &gt; pivot) swap(arr, i, gt--); else i++; &#125; sortThreeWay(arr, lo, lt - 1); sortThreeWay(arr, gt + 1, hi);&#125; Analysis: N lg N when all distinct; linear when only a constant number of distinct keys; randomized quicksort with 3-way partitioning reduces running time from linearithmic to linear in broad class of applications; System SortsArrays.sort(): has different method for each primitive type; has a method for data types that implement Comparable; has a method that uses a Comparator; uses tuned quicksort for primitive types; tuned mergesort for objects; Summary Complexity of SortingModel of computation: decision tree; Cost model: # compares; Upper bound: N * lg N (from merge sort); Lower bound: lg(N!) ~ N * lg N (from decision tree); Optimal algorithm: merge sort (with respect to number compares, not to space usage); Comparable and Comparator in JavaComparable Interface12345678public class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; public int compareTo(Student o) &#123; return this.age - o.age; &#125;&#125; Comparator Interfacewe can compare the same data type in different ways using comparator interface; 12345678910111213141516171819public class Student &#123; public static final Comparator&lt;Student&gt; BY_NAME = new ByName(); public static final Comparator&lt;Student&gt; BY_AGE = new ByAge(); public String name; public int age; private static class ByName implements Comparator&lt;Student&gt; &#123; public int compare(Student o1, Student o2) &#123; return o1.name.compareTo(o2.name); &#125; &#125; private static class ByAge implements Comparator&lt;Student&gt; &#123; public int compare(Student o1, Student o2) &#123; return o1.age - o2.age; &#125; &#125;&#125; StabilityA stable sort preserves the relative order of items with equal keys. Equal items never move past each other. Insertion Sort and Merge Sort are stable. Interview Questions Dutch national flag. See LC-75 (https://leetcode.com/problems/sort-colors/) 12345678910111213141516171819202122232425262728public void sortColors(int[] nums) &#123; if (nums == null) throw new IllegalArgumentException(); int p0 = 0; int p2 = nums.length - 1; int i = 0; while (i &lt;= p2) &#123; switch (nums[i]) &#123; case 2: swap(nums, i, p2); p2--; break; case 0: swap(nums, i, p0); p0++; default: i++; break; &#125; &#125;&#125;private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; Counting inversions. An inversion in an array a[] is a pair of entries a[i] and a[j] such that i&lt;*j* but *a*[*i*]&gt;a[j]. Given an array, design a linearithmic algorithm to count the number of inversions. Hint: count while mergesorting; 1234567891011121314151617181920212223242526272829303132333435363738private int mergeAndCount(int[] arr, int[] aux, int lo, int mid, int hi) &#123; System.arraycopy(arr, lo, aux, lo, hi - lo + 1); int count = 0; int i = lo; int j = mid + 1; int k = lo; while (i &lt;= mid &amp;&amp; j &lt;= hi) &#123; // arr[k++] = aux[i] &lt;= aux[j] ? aux[i++] : aux[j++]; if (aux[i] &lt;= aux[j]) &#123; arr[k++] = aux[i++]; &#125; else &#123; arr[k++] = aux[j++]; count += mid - i + 1; &#125; &#125; while (i &lt;= mid) &#123; arr[k++] = aux[i++]; &#125; while (j &lt;= hi) &#123; arr[k++] = aux[j++]; &#125; return count;&#125;private int mergeSortAndCount(int[] arr, int[] aux, int lo, int hi) &#123; if (hi &lt;= lo) return 0; int count = 0; int mid = (lo + hi) / 2; count += mergeSortAndCount(arr, aux, lo, mid); count += mergeSortAndCount(arr, aux, mid + 1, hi); count += mergeAndCount(arr, aux, lo, mid, hi); return count;&#125; reference: https://www.geeksforgeeks.org/counting-inversions/ Selection in two sorted arrays. Given two sorted arrays a[] and b[], of lengths n1 and n2 and an integer 0≤k&lt;n1+n2, design an algorithm to find a key of rank k. The order of growth of the worst case running time of your algorithm should be log n, where n=n1+n2. reference: https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/ LC-4 [https://leetcode.com/problems/median-of-two-sorted-arrays/] explain: https://www.youtube.com/watch?v=q6IEA26hvXc Decimal dominants. Given an array with nn keys, design an algorithm to find all values that occur more than n/10 times. The expected running time of your algorithm should be linear. R: https://massivealgorithms.blogspot.com/2019/03/decimal-dominants.html Assignmenthttps://coursera.cs.princeton.edu/algs4/assignments/collinear/specification.php https://github.com/Fimon12138/coursera/tree/master/algs4_princeton/collinear","tags":[{"name":"algo","slug":"algo","permalink":"http://wiki.hellofimon.icu/tags/algo/"},{"name":"sort","slug":"sort","permalink":"http://wiki.hellofimon.icu/tags/sort/"}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/"},{"name":"Algorithms","slug":"刷题/Algorithms","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/"},{"name":"algs4-Princeton","slug":"刷题/Algorithms/algs4-Princeton","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/algs4-Princeton/"}]},{"title":"LinkedList","date":"2021-12-16T18:15:00.000Z","path":"wiki/刷题/《程序员代码面试指南》/LinkedList/","text":"删除节点 倒数第 k 个：（lc-19，双指针） 1234567891011121314151617181920212223242526public ListNode removeNthFromEnd(ListNode head, int n) &#123; if (head == null) &#123; return null; &#125; ListNode dummy = new ListNode(); dummy.next = head; ListNode front = dummy; for (int i = 0; i &lt; n + 1; i++) &#123; if (front == null) &#123; // length of list is less than n return dummy.next; &#125; front = front.next; &#125; ListNode end = dummy; while (front != null) &#123; front = front.next; end = end.next; &#125; end.next = end.next.next; return dummy.next; &#125; 中间节点：（lc-2095，快慢指针） 12345678910111213141516171819public ListNode deleteMiddle(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = head; ListNode slow = head; ListNode prev = dummy; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; prev = prev.next; &#125; prev.next = prev.next.next; return dummy.next;&#125; 删除重复节点：sorted / unsorted 反转链表 整个链表 部分链表 链表相交 合并链表","tags":[{"name":"algo","slug":"algo","permalink":"http://wiki.hellofimon.icu/tags/algo/"},{"name":"linkedlist","slug":"linkedlist","permalink":"http://wiki.hellofimon.icu/tags/linkedlist/"}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/"},{"name":"《程序员代码面试指南》","slug":"刷题/《程序员代码面试指南》","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E3%80%8B/"}]},{"title":"stacks and queues","date":"2021-12-02T05:44:00.000Z","path":"wiki/刷题/Algorithms/algs4-Princeton/stacks-and-queues/","text":"Stack LIFO: last in first out API: push(), pop(), isEmpty() Implementation: linked-list: maintain pointer to first node in a linked list, insert/remove from front; O(1) time complexity for every operation in worst case; 40 N bytes for a stack with N items (in Java); resizing array: client is required to provide capacity at the beginning; if array is full, create a new array of twice the size, and copy items; halve size of array s[] when array is one-quarter full; better space complexity; Queue FIFO: first in first out API: enqueue(), dequeue(), isEmpty() implementation: linked-list: maintain pointer to first and last nodes in a linked list, insert at end of linked list, remove from front of linked list; resizing array: Update head and tail modulo the capacity; Application Dijkstra’s two-stack algorithm (calculator) Questions Implement a queue with two stacks so that each queue operations takes a constant amortized number of stack operations; Create a data structure that efficiently supports the stack operations (push and pop) and also a return-the-maximum operation. Assume the elements are real numbers so that you can compare them;","tags":[{"name":"algo","slug":"algo","permalink":"http://wiki.hellofimon.icu/tags/algo/"},{"name":"data structure","slug":"data-structure","permalink":"http://wiki.hellofimon.icu/tags/data-structure/"},{"name":"stack","slug":"stack","permalink":"http://wiki.hellofimon.icu/tags/stack/"},{"name":"queue","slug":"queue","permalink":"http://wiki.hellofimon.icu/tags/queue/"}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/"},{"name":"Algorithms","slug":"刷题/Algorithms","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/"},{"name":"algs4-Princeton","slug":"刷题/Algorithms/algs4-Princeton","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/algs4-Princeton/"}]},{"title":"Git","date":"2021-12-01T14:28:00.000Z","path":"wiki/Tools/Git/","text":"Referencehttps://git-scm.com/docs 常用命令 配置 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx&quot; 配置 ssh 1ssh-keygen -t rsa -C &quot;xxx&quot; 初始化 git 仓库 1git init 添加远程仓库， origin 是远程仓库别名，可以为一个本地仓库关联多个远程仓库 1git remote add origin git@xxx 关联本地分支和远程分支，也可以在 push 时使用 -u 123git branch --set-upstream-to=origin/master mastergit push -u origin master 强制关联两个不相关分支 1git pull --allow-unrelated-histories","tags":[{"name":"git","slug":"git","permalink":"http://wiki.hellofimon.icu/tags/git/"}],"categories":[{"name":"Tools","slug":"Tools","permalink":"http://wiki.hellofimon.icu/categories/Tools/"}]},{"title":"11/2021","date":"2021-11-28T14:28:00.000Z","path":"wiki/日记/112021/","text":"感恩节的假期什么也没干，本来计划好好写的作业也一点没动，一个OA耗了很长时间，记一些小的细节，日后有空整理整理： apt-get 的 node 版本太低，新版的 node 自带 npm， 不用单独安装； nginx 部署 Vue 后页面 403 可能是 nginx 权限不够，直接给 root 权限； Express； Jest，Vue 的单元测试； Vue 3，vue-cli； 同学们陆续都上岸了，我连面试都没有，good luck 吧！","tags":[],"categories":[{"name":"日记","slug":"日记","permalink":"http://wiki.hellofimon.icu/categories/%E6%97%A5%E8%AE%B0/"}]},{"title":"union find","date":"2021-11-10T08:08:00.000Z","path":"wiki/刷题/Algorithms/algs4-Princeton/union-find/","text":"Quick-find Data structure: integer array id[] of length N; Union: to union p and q, change all entries whose id equals id[p] to id[q]; Find: check if p and q have the same id; Time Complexity: O(n) for union and O(1) for find; union is too expensive; 123456789101112void union(int p, int q) &#123; int pid = id[p]; int qid = id[q]; for (int i=0; i&lt;id.length; i++) &#123; if (id[i] == pid) id[i] = qid; &#125;&#125; boolean find(int p, int q) &#123; return id[p] == id[q];&#125; Quick-union(lazy approach) Union: to union p and q, set the id of p’s root to q’s root; Find: check if p and q have the same root; Time complexity: O(n) for union and O(n) for find; trees can get very tall, and find will be expensive; 123456789101112131415int root(int i) &#123; while (i != id[i]) i = id[i]; return i;&#125;void union(int p, int q) &#123; int i = root(p); int j = root(q); id[i] = j;&#125;boolean find(int p, int q) &#123; return root(p) == root(q);&#125; Weighted Quick-union Modify quick-union to avoid tall trees: keep track of size of each tree; balance by linking root of smaller tree to root of larger tree; Time Complexity: O(lgN) for union and O(lgN) for find; Depth of any node is at most lgN (this can be proved); 123456789101112131415int[] sz = new int[id.length];void union(int p, int q) &#123; int i = root(p); int j = root(q); if (i != j) &#123; if (sz[i] &lt; sz[j]) &#123; id[i] = j; sz[j] += sz[i]; &#125; else &#123; id[j] = i; sz[i] += sz[j]; &#125; &#125;&#125; Quick-union with path compression After computing root of p, set the id of each examined node to point to that root; Time complexity: O(lg*N) for both union and find; 1234567int root(int i) &#123; while (i != id[i]) &#123; id[i] = id[id[i]]; i = id[i]; &#125; return i;&#125;","tags":[{"name":"algo","slug":"algo","permalink":"http://wiki.hellofimon.icu/tags/algo/"},{"name":"union-find","slug":"union-find","permalink":"http://wiki.hellofimon.icu/tags/union-find/"}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/"},{"name":"Algorithms","slug":"刷题/Algorithms","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/"},{"name":"algs4-Princeton","slug":"刷题/Algorithms/algs4-Princeton","permalink":"http://wiki.hellofimon.icu/categories/%E5%88%B7%E9%A2%98/Algorithms/algs4-Princeton/"}]},{"title":"Welcome to Fimon's Wiki Site","date":"2021-06-29T07:30:33.000Z","path":"wiki/index/","text":"这是我的个人 Wiki 站点，用于记录平时学习的内容，方便以后查阅。 第一次接触 Wiki 这个词是 20 年夏天在 Shopee 深圳实习的时候，当时用的是 Confluence。后来继续去了美团北京实习，美团的 Wiki（学城），除了给工作带来了很大的便利，也丰富了空闲时间。 后来觉得学习的过程中有这样一个东西用来记记笔记还是很有必要的。之前也尝试搭建过博客，但是总感觉博客更像是写给别人看的。因为感觉 Wordpress 有点复杂且学习成本较高，就转向了 Github Pages，在浏览 Hexo 主题时意外发现了这个主题，也算是一种缘分。 感谢 Wikitten 的作者，也希望我的站点里有一些对你有帮助的内容。","tags":[],"categories":[]},{"title":"搭建步骤","date":"2021-06-29T02:25:27.000Z","path":"wiki/关于本站/搭建步骤/","text":"本地安装 Hexo1234npm install -g hexo# 查看版本hexo -v 创建项目文件夹本地新建文件夹，作为存放项目文件的位置。进入文件夹后，执行hexo初始化命令： 1hexo init 可以直接使用Git Bash。 更换主题将目标hexo主题的资源下载到themes文件夹下，这里以Wikitten为例： 1git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten 关于此主题的使用可直接参考其文档（参考-2）。 参数配置有两个文件需要配置，一个是hexo项目的_config.yml，一个是Wikitten主题的_config.yml。 项目配置文件，下面列出了需要补充或修改的内容（结合官方文档使用）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# Hexo Configuration# Sitetitle: Fimon&#x27;s Wikisubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: Fimonlanguage: entimezone: Asia/Shanghai# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: http://wiki.hellofimon.icu/permalink: wiki/:title/# Directoryskip_render: - README.md# Writing## Markdownmarked: gfm: true ## PluginsjsonContent: meta: false pages: title: true date: true path: true text: true posts: title: true date: true path: true text: true tags: true categories: true ignore: - 404.html ### Creat sitemapsitemap: path: sitemap.xml ## https://github.com/zthxxx/hexo-directory-category auto_dir_categorize: enable: true force: false# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/## 切换主题theme: wikitten# Deployment## Docs: https://hexo.io/docs/one-command-deployment## 通过Github部署，通过此配置可直接由hexo d部署deploy: type: git repository: git@github.com:xxx/xxx.git branch: master 主题配置文件没有太多需要修改，参考官方文档即可。 部署12345678# 生成页面hexo g# 本地预览hexo s# 部署hexo d 绑定域名在项目下新建一个CNAME文件，在其中输入自定义的域名。下图为Github-&gt;Settings-&gt;Pages截图，设置Custom Domin本质上也是在项目中加上CNAME文件，但是通过此种方式设置的CNAME文件会在下次部署时被覆盖掉。可以在本地将CNAME文件放到ｓｏｕｒｃｅ文件夹下，这样可以避免文件被覆盖（logo等图标同理，参考－３）。 去DNS域名服务商添加相应的记录： 注意选择CNAME方式。 参考资料 hexo安装及使用：https://sspai.com/post/62441 Wikitten使用文档：https://github.com/zthxxx/hexo-theme-Wikitten/blob/master/README_zh-CN.md 避免CNAME文件被覆盖：https://www.jianshu.com/p/b6fe1c5c74ed 更换域名：https://zhuanlan.zhihu.com/p/60578464；https://segmentfault.com/a/1190000003946969","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wiki.hellofimon.icu/tags/hexo/"}],"categories":[{"name":"关于本站","slug":"关于本站","permalink":"http://wiki.hellofimon.icu/categories/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/"}]}]}